//----------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <chrono>
#include "source/NodeType.h"
#include "source/Node.h"
#include "source/Calculator.h"
#include "source/StopFlag.h"
#include "source/IO.h"
#include "source/NodeProcessor.h"
#include <omp.h>

#include <pybind11/pybind11.h>
#include <pybind11/embed.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <pybind11/eval.h>

namespace py = pybind11;

using namespace std;
using namespace std::chrono;
using namespace orchestracpp;

//----------------------------------------

//defining C++ class
struct ORCHESTRA{
public:
    //allocating variables
    NodeType nodeType;          
    Calculator* calculator;         //calculator POINTER object
    FileBasket* fileBasket;         //filebasket POINTER object
    StopFlag* stopFlag;             //stopflag POINTER object
    //Node* node1;                     //node POINTER object
    //Node* tmpnode;                  //nodes that will be copied
    std::vector<Node*>* theNodes;   //vector containing all nodes
    vector<int> index_vector;       //vector listing the indices of IO variables
    vector<int> IN_index;          //vector listing the indices of the Input variables
    vector<int> OUT_index;          //vector listing the indices of the Output variables
    vector<vector<float>> O_values; //vector with the output values of the equilibrium calculation
    
    //defining functions
    void initialise(std::string inputfile, int no_buckets, vector<std::string> input, vector<std::string> output){
        //FUNCTION 1: INITIALISE
        //this function creates the calculator & node objects that will be used in the subsequent calculations.
        //as the objects are specified within the ORCHESTRA C++ class (see above), they are "remembered" when calling
        //them in the calculate function.

        //create stopFlag
        stopFlag = new StopFlag();
        
        //create fileBasket
        fileBasket = new FileBasket();
        
        //create calculator object
        calculator = new Calculator(inputfile);

        //base nodeType on calculator object
        nodeType.useGlobalVariablesFromCalculator(calculator);
               
        //loop over input parameters and add to IO
        cout << "testing:" << endl;
        for (int n=0 ; n< input.size(); n++){
            nodeType.addVariable(input[n], 0, false, "test");
        };

        //loop over output parameters and add to IO
        for (int n =0 ; n<output.size(); n++){
            nodeType.addVariable(output[n], 0, false, "test");
        };

        //it is necessary to used indices that are generated by the nodeType, as the nodeType uses negative indices for static variables
        //two vectors with indices are made, one for input and one for output variables
        //for INPUT:
        for (int n =0 ; n< input.size(); n++) {
            IN_index.push_back(nodeType.index(input[n]));
            cout << nodeType.index(input[n]) << ":" << input[n] << endl;
        };

        //and for OUTPUT:
        for (int n =0 ; n< output.size(); n++){
            OUT_index.push_back(nodeType.index(output[n]));
            cout << nodeType.index(output[n]) << ":" << output[n] << endl;
        };              

        //creating first node object
        Node node1(&nodeType); //create first node
        
        //cloning the nodes and add them to a nodes-list
        theNodes = new std::vector<Node*>;
        for (int n=0; n<no_buckets;n++){
            Node* tmpNode = node1.clone(); //we copy the first node
            theNodes->push_back(tmpNode);
        };
	
	
        IO::println("Initialise Completed! the following IO parameters will be used:");

        //at the end write all IO variables for the first node.
        for (int n = 0; n < nodeType.getNrVars(); n++) {
            cout<< n << " : " << nodeType.getName(n)<< " : "<<   theNodes->at(0)->getvalue(n)  <<endl;
		};
    };
    
    void updatevalues(vector<vector<float>> I_values){
    	//FUNCTION 2: updatevalues
    	//this function updates the total values for the nodes
    	//if components that define the equilibrium are not specified in this array, the default (from the input chemistry file) is taken.
    	
    	//change values based on input list
    	for (int n=0; n<theNodes->size();n++){
    	    for (int m=0; m<IN_index.size();m++){
    	        theNodes->at(n)->setValue(IN_index[m],I_values[n][m]);
    	    };
    	};
    };
    
    py::array_t<float> calculate(){
    	//FUCTION 3: CALCULATE
    	//calculates the chemical equilibrium
    	//the output is a list (length is equal to length of input array) with values at equilibrium.
    	
    	//calculating
    	bool success = false;
    	for (int n=0; n<theNodes->size();n++){
    	    success = calculator->calculate(theNodes->at(n),stopFlag);
    	};
    	
        //update IO and return to Python
        vector<vector<float>> O_values(theNodes->size(),vector<float>(OUT_index.size())); //make output vector
        for (int n=0; n<theNodes->size();n++){
            for (int m=0; m<OUT_index.size();m++){
                O_values[n][m] = theNodes->at(n)->getvalue(OUT_index[m]);
            };
        };
        
        return py::cast(O_values); //return list with output values
    };
    
    py::array_t<float> set_and_calculate(vector<vector<float>> I_values){
        //FUNCTION 2: CALCULATE
        //this function calculates chemical equilibrium based on the input array. if components that define this equilibrium
        //are not specified in this array, the default (from the input chemistry file) is taken.
        //the output is a list (length is equal to length of input array) with values at equilibrium

        //change values based on input list
        for (int n=0; n<theNodes->size();n++){
            for (int m=0; m<IN_index.size();m++){
                theNodes->at(n)->setValue(IN_index[m],I_values[n][m]);
            };
        };

        //calculating
        bool success = false;
        for (int n =0; n <theNodes->size();n++){
            success = calculator->calculate(theNodes->at(n),stopFlag);
        };

        //make output vector
        vector<vector<float>> O_values(theNodes->size(),vector<float>(OUT_index.size())); //make output vector
        for (int n=0; n<theNodes->size();n++){
            for (int m=0; m<OUT_index.size();m++){
                O_values[n][m] = theNodes->at(n)->getvalue(OUT_index[m]);
            };
        };
        
        return py::cast(O_values); //return list with output values
    };
    
};

//HERE WE MAKE THE WRAPPER WITH PYBIND11
PYBIND11_MODULE(PyORCHESTRA,m){
    py::class_<ORCHESTRA>(m, "ORCHESTRA") //define class name
    .def(py::init<>())
    .def("initialise", &ORCHESTRA::initialise) //refer to function initialise
    .def("updatevalues", &ORCHESTRA::updatevalues) //refer to function updatevalues
    .def("calculate", &ORCHESTRA::calculate) //refer to function calculate
    .def("set_and_calculate", &ORCHESTRA::set_and_calculate); //refer to function calculate2
};

